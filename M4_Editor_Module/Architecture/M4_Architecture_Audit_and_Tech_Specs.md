# SheYan M4 编辑模块架构审计与技术规范

**版本:** 1.0
**日期:** 2026-02-26
**负责人:** Manus AI

## 1. 概述

本文档旨在响应“SheYan 编辑模块 (M4) 满血版开发任务书”中的“满血审查指令”，针对提出的三个核心架构问题进行详细阐述。内容涵盖参数序列化方案、实时预览性能优化策略，以及对标顶级竞品的美颜塑形算法承诺。本文将作为 M4 模块开发的技术基石与核心规范。

---

## 2. 架构审计回答

根据任务书要求，现对以下三个关键问题进行正式、详尽的回答。

### 2.1 参数冗余性：叠加参数的序列化与调用方案

当用户在编辑模块中叠加使用多种工具（例如，5个核心工具 + 1个大师滤镜）后，为了确保这些复杂的编辑参数能够在相机模块中被 1:1 精确调用，我们将设计一套健壮、可扩展且向后兼容的参数序列化方案。

**核心设计：基于 JSON 的有序编辑操作栈 (Ordered Edit Stack)**

我们将不采用扁平化的键值对来存储参数，因为编辑操作的顺序至关重要（例如，先锐化后加颗粒与先加颗粒后锐化的视觉效果截然不同）。因此，所有编辑操作将被记录为一个**有序的操作数组**，并以 JSON 格式进行封装。该 JSON 对象将包含版本信息和操作栈两个主要部分。

下面是一个具体的示例，描述了用户依次使用了曝光、对比度、锐化、暗角、大师滤镜以及裁剪后的参数结构：

```json
{
  "sheyan_version": "M4.1",
  "edit_stack": [
    { "tool_id": "exposure", "params": { "value": 0.85 } },
    { "tool_id": "contrast", "params": { "value": -0.15 } },
    { "tool_id": "sharpen", "params": { "value": 0.6 } },
    { "tool_id": "vignette", "params": { "intensity": 0.4, "color": "#000000" } },
    { "tool_id": "master_filter", "params": { "filter_id": "film_05", "intensity": 0.75 } },
    { "tool_id": "crop", "params": { "aspect_ratio": "16:9", "rect": [0.1, 0.1, 0.8, 0.9] } }
  ]
}
```

**存储与备份机制**

1.  **图片元数据嵌入 (Metadata Embedding):** 上述 JSON 字符串将被完整地存入图片文件的元数据中。我们将遵循行业标准，使用 **XMP (Extensible Metadata Platform)** 规范，创建一个自定义的 `SheYan` 命名空间（例如 `SheYan:EditParams`）来存储这串数据。相比直接写入 EXIF，XMP 提供了更好的结构化数据支持和扩展性，确保了数据的完整性和规范性。

2.  **Git 备份 (Git Backup):** 在用户保存图片时，除了生成带元数据的新图片，该 JSON 数据也会被提取出来，并同步到用户的 Git 仓库中。这确保了即使用户更换设备或清除本地缓存，其精心调校的“雁宝记忆”参数也能永久保留，并在任何时候通过相机模块调用。

**调用逻辑 (Recall Logic)**

当用户在相机模块点击“雁宝记忆”并选择一张带有参数的照片时，系统将：
1.  读取并解析图片 XMP 元数据中的 `SheYan:EditParams` 字段。
2.  校验 `sheyan_version` 以处理未来可能出现的版本兼容问题。
3.  遍历 `edit_stack` 数组，按照**严格的顺序**，将每个 `tool_id` 及其 `params` 应用于实时预览的渲染管线中。这将确保 1:1 的视觉效果复刻。

### 2.2 性能优化：实时预览的缓存策略

在处理 91 个大师滤镜的实时预览和 29D 渲染参数的动态调节时，保证编辑过程的流畅性（不卡顿）是交互体验的核心。我们将采取多层次的缓存与渲染优化策略。

| 场景 | 核心挑战 | 优化策略 |
| :--- | :--- | :--- |
| **91个滤镜预览** | 实时将 91 个不同 LUT 应用于高清预览图，计算量巨大。 | **1. 缩略图缓存:** 首次进入编辑模块时，后台异步生成所有滤镜的缩略图并缓存。用户滑动列表时，看到的是预渲染的静态图片，实现“零延迟”浏览。<br>**2. 实时渲染降级:** 仅当用户**停止滑动并选中**某个滤镜时，才将该滤镜的完整 LUT 应用于高清实时预览区。<br>**3. GPU 加速:** 所有 LUT 纹理和图像处理均在 GPU 上通过高度优化的着色器 (Shader) 完成。 |
| **滤镜强度调节** | 在 0-100 之间平滑调节滤镜强度，需要实时混合两张图像。 | **线性插值 (Lerp):** 将原始图像和应用 100% 强度滤镜后的图像作为两个输入纹理。调节滑块时，仅需在着色器中改变一个 `intensity` (0.0-1.0) 的 uniform 变量，通过 `mix()` 函数进行高速线性插值。此操作在 GPU 上几乎是零成本的。 |
| **29D 渲染调节** | 29 个渲染维度参数（如光子反弹、纹理置换）相互影响，计算复杂。 | **1. 渲染管线降级:** 在用户拖动滑块时，暂时使用一个**计算量较低的近似渲染模型**或降低预览分辨率，保证滑块的实时响应。<br>**2. 延迟更新 (Debounce):** 仅在用户**停止拖动滑块后**（例如，延迟 100 毫秒），才触发一次完整的、高质量的 29D 渲染计算，并更新高清预览。<br>**3. 依赖图分析:** 分析 29 个参数间的依赖关系，当某个参数变动时，仅重新计算其影响的渲染节点，而非整个渲染链。 |

通过上述“预计算+降级渲染+延迟更新”的组合策略，我们可以在保证最终效果精确性的前提下，为用户提供流畅、无卡顿的实时编辑体验。

### 2.3 对标承诺：手动修容算法

针对“美颜塑形”中的“手动重塑”功能，我们承诺，Manus 将提供**等同于当前一线修图 App（如 FaceApp, Meitu, Facetune）核心水准的“手动修容”算法**。

**技术实现路径：**

1.  **AI 人脸关键点检测:** 我们将采用高精度的 AI 模型，实时检测并追踪超过 200 个人脸关键点，覆盖五官、脸部轮廓、皮肤区域等。这是所有手动修容功能的基础。

2.  **液化与网格变形 (Liquify & Mesh Warping):** “推脸”、“手动瘦身”等功能将基于 GPU 加速的网格变形算法实现。用户触摸屏幕时，系统会根据其手势（推、拉、缩放）动态修改一个覆盖在图像上的虚拟网格，并通过纹理查找将图像像素映射到变形后的网格上，从而产生平滑、自然的形变效果。

3.  **AI 驱动的智能修复:** “祛痘”、“消除笔”等功能将结合 AI 实现。当用户涂抹一个区域时，算法不仅是简单的模糊或复制周边像素，而是会：
    > - **内容感知填充 (Content-Aware Fill):** 智能分析涂抹区域周围的纹理、光照和颜色，并从图像的其他部分寻找最合适的像素进行无缝填充，确保修复后的区域与周围环境完美融合。
    > - **皮肤纹理重建:** 在填充后，算法会重新生成符合真实感的皮肤纹理，避免出现模糊、平滑的“假皮”感。

**对标承诺总结:**

我们的手动修容功能将不仅仅是基础的图像处理，而是深度融合了 AI 技术的智能编辑。我们有信心在**操作的精准度、效果的自然度、处理的实时性**三个维度上，达到或超越业界顶级水平，为用户提供专业且易用的手动精修体验。

---

**文档结束**
